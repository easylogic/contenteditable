---
import SiteNav from '../../../../components/SiteNav.astro';
import BaseHead from '../../../../components/BaseHead.astro';
import TableOfContents from '../../../../components/TableOfContents.astro';
import DocCodeBlock from '../../../../components/docs/DocCodeBlock.astro';
import DocSection from '../../../../components/docs/DocSection.astro';
import DocNavigation from '../../../../components/docs/DocNavigation.astro';
import '../../../../styles/global.css';
import {
  locales,
  supportedLocales,
  defaultLocale,
  getLocalizedPath,
  type Locale,
} from '../../../../i18n/translations';
import type { GetStaticPaths } from 'astro';

export const getStaticPaths = (() => {
  return supportedLocales
    .filter((locale) => locale !== defaultLocale)
    .map((locale) => ({
      params: { locale },
    }));
}) satisfies GetStaticPaths;

const locale = Astro.params.locale as Locale;
const localePath = (path: string) => getLocalizedPath(path, locale);
const localeInfo = locales[locale];

const headings = [
  { depth: 2, slug: 'overview', text: '개요' },
  { depth: 2, slug: 'event-bubbling', text: '이벤트 버블링 및 캡처' },
  { depth: 3, slug: 'bubbling-implementation', text: '버블링 구현' },
  { depth: 3, slug: 'capture-phase', text: '캡처 단계' },
  { depth: 2, slug: 'event-delegation', text: '이벤트 위임 패턴' },
  { depth: 3, slug: 'delegation-benefits', text: '위임의 이점' },
  { depth: 3, slug: 'delegation-implementation', text: '위임 구현' },
  { depth: 2, slug: 'custom-events', text: '커스텀 이벤트 시스템' },
  { depth: 3, slug: 'typed-events', text: '타입화된 이벤트' },
  { depth: 3, slug: 'event-priority', text: '이벤트 우선순위' },
  { depth: 2, slug: 'event-lifecycle', text: '이벤트 생명주기' },
];
---

<html lang={localeInfo.code} dir={localeInfo.dir}>
  <head>
    <BaseHead
      title="이벤트 시스템 아키텍처 – 에디터 아키텍처 – contenteditable.lab"
      description="이벤트 시스템 아키텍처 이해: 이벤트 버블링, 위임, 커스텀 이벤트 시스템"
    />
  </head>
  <body>
    <SiteNav />
    <main class="flex max-w-full m-0 p-0">
      <section class="flex-1 flex max-w-[1120px] mx-auto py-7 px-5 pb-10 gap-6 w-full">
        <div class="flex-1">
          <header class="mb-8">
            <nav class="mb-4 text-sm">
              <a href={localePath('/')} class="text-text-muted no-underline">홈</a>
              <span class="text-text-faint mx-2">/</span>
              <a href={localePath('/editor')} class="text-text-muted no-underline">에디터</a>
              <span class="text-text-faint mx-2">/</span>
              <a href={localePath('/editor/architecture')} class="text-text-muted no-underline">아키텍처</a>
              <span class="text-text-faint mx-2">/</span>
              <span class="text-text-primary">이벤트 시스템</span>
            </nav>
            <h1 class="text-3xl leading-tight m-0 mb-2">
              이벤트 시스템 아키텍처
            </h1>
            <p class="m-0 text-[0.95rem] text-text-secondary">
              잘 설계된 이벤트 시스템은 플러그인이 에디터 상태 변경과 사용자 상호작용에 반응할 수 있게 합니다.
            </p>
          </header>

          <article class="rounded-xl border border-border-light bg-bg-surface p-6 px-7 text-[0.9rem] leading-[1.7]">
            <DocSection id="overview" title="개요">
              <p class="m-0 mb-4">
                이벤트 시스템은 에디터 코어와 플러그인 간의 통신 레이어입니다. 플러그인이 에디터 상태 변경, 사용자 상호작용, 생명주기 이벤트를 수신하고 반응할 수 있게 합니다.
              </p>
              <p class="m-0 mb-4">
                잘 설계된 이벤트 시스템은 타입 안전성, 효율적인 이벤트 전파, 유연한 이벤트 처리 패턴을 제공합니다.
              </p>
            </DocSection>

            <DocSection id="event-bubbling" title="이벤트 버블링 및 캡처">
              <DocSection id="bubbling-implementation" title="버블링 구현" depth={3}>
                <p class="m-0 mb-3">
                  DOM 이벤트와 유사하게 이벤트 버블링을 구현하여 부모 핸들러가 자식보다 먼저 이벤트를 처리할 수 있게 합니다:
                </p>
                <DocCodeBlock language="typescript" code={`class EventEmitter {
  #listeners = new Map();
  
  on(event, handler, options) {
    if (!this.#listeners.has(event)) {
      this.#listeners.set(event, new Set());
    }
    this.#listeners.get(event).add(handler);
  }
  
  emit(event, data, bubbles = true) {
    const handlers = this.#listeners.get(event);
    if (handlers) {
      handlers.forEach(handler => {
        handler(data);
      });
    }
    
    // Bubble up to parent
    if (bubbles && this.#parent) {
      this.#parent.emit(event, data, true);
    }
  }
}

// Usage: Node-level events bubble to document
class DocumentNode {
  constructor(parent) {
    this.#parent = parent;
    this.#emitter = new EventEmitter();
  }
  
  emit(event, data) {
    // Emit on this node
    this.#emitter.emit(event, data, false);
    
    // Bubble to parent
    if (this.#parent) {
      this.#parent.emit(event, data);
    }
  }
}

// Handler on document receives all node events
document.on('textInsert', (data) => {
  console.log('Text inserted anywhere in document:', data);
});`} />
              </DocSection>

              <DocSection id="capture-phase" title="캡처 단계" depth={3}>
                <p class="m-0 mb-3">
                  버블링 전에 처리되어야 하는 이벤트를 위한 캡처 단계를 지원합니다:
                </p>
                <DocCodeBlock language="typescript" code={`class EventEmitter {
  #captureListeners = new Map();
  #bubbleListeners = new Map();
  
  on(event, handler, options = {}) {
    const listeners = options.capture 
      ? this.#captureListeners 
      : this.#bubbleListeners;
    
    if (!listeners.has(event)) {
      listeners.set(event, new Set());
    }
    listeners.get(event).add(handler);
  }
  
  emit(event, data) {
    // Capture phase: parent to child
    this.#emitCapture(event, data);
    
    // Target phase: current node
    this.#emitTarget(event, data);
    
    // Bubble phase: child to parent
    this.#emitBubble(event, data);
  }
  
  #emitCapture(event, data) {
    // Emit to capture listeners
    const handlers = this.#captureListeners.get(event);
    if (handlers) {
      handlers.forEach(handler => handler(data));
    }
    
    // Continue to children
    this.#children.forEach(child => {
      child.#emitCapture(event, data);
    });
  }
  
  #emitBubble(event, data) {
    // Emit to bubble listeners
    const handlers = this.#bubbleListeners.get(event);
    if (handlers) {
      handlers.forEach(handler => handler(data));
    }
    
    // Continue to parent
    if (this.#parent) {
      this.#parent.#emitBubble(event, data);
    }
  }
}`} />
              </DocSection>
            </DocSection>

            <DocSection id="event-delegation" title="이벤트 위임 패턴">
              <DocSection id="delegation-benefits" title="위임의 이점" depth={3}>
                <p class="m-0 mb-3">
                  이벤트 위임은 메모리 사용을 줄이고 성능을 향상시킵니다:
                </p>
                <ul class="m-0 mb-4 pl-6">
                  <li>개별 노드에 많은 리스너 대신 컨테이너에 단일 리스너</li>
                  <li>동적으로 추가된 노드에서도 작동</li>
                  <li>이벤트 리스너 오버헤드 감소</li>
                  <li>이벤트 관리 단순화</li>
                </ul>
              </DocSection>

              <DocSection id="delegation-implementation" title="위임 구현" depth={3}>
                <p class="m-0 mb-3">
                  이벤트를 효율적으로 처리하기 위해 이벤트 위임을 사용합니다:
                </p>
                <DocCodeBlock language="typescript" code={`class Editor {
  constructor(container) {
    this.#container = container;
    
    // Single listener on container
    this.#container.addEventListener('click', (e) => {
      this.#handleClick(e);
    });
    
    this.#container.addEventListener('input', (e) => {
      this.#handleInput(e);
    });
  }
  
  #handleClick(e) {
    const target = e.target;
    
    // Find the model node for this DOM element
    const node = this.#findNodeForElement(target);
    if (!node) return;
    
    // Dispatch to appropriate handler based on node type
    switch (node.type) {
      case 'link':
        this.#handleLinkClick(node, e);
        break;
      case 'image':
        this.#handleImageClick(node, e);
        break;
    }
  }
  
  #handleInput(e) {
    // Convert DOM input to model operation
    const operation = this.#domToOperation(e);
    this.applyOperation(operation);
  }
  
  #findNodeForElement(element) {
    // Walk up DOM tree to find node marker
    let current = element;
    while (current && current !== this.#container) {
      const nodeId = current.getAttribute('data-node-id');
      if (nodeId) {
        return this.#getNodeById(nodeId);
      }
      current = current.parentElement;
    }
    return null;
  }
}`} />
              </DocSection>
            </DocSection>

            <DocSection id="custom-events" title="커스텀 이벤트 시스템">
              <DocSection id="typed-events" title="타입화된 이벤트" depth={3}>
                <p class="m-0 mb-3">
                  타입화된 이벤트로 커스텀 이벤트 시스템을 구현합니다:
                </p>
                <DocCodeBlock language="typescript" code={`// Define event types
const EditorEvents = {
  OPERATION: 'operation',
  SELECTION_CHANGE: 'selectionChange',
  DOCUMENT_CHANGE: 'documentChange',
  ERROR: 'error'
};

// Typed event emitter
class TypedEventEmitter {
  #listeners = new Map();
  
  on(event, handler) {
    if (!this.#listeners.has(event)) {
      this.#listeners.set(event, new Set());
    }
    this.#listeners.get(event).add(handler);
  }
  
  off(event, handler) {
    const handlers = this.#listeners.get(event);
    if (handlers) {
      handlers.delete(handler);
    }
  }
  
  emit(event, data) {
    const handlers = this.#listeners.get(event);
    if (handlers) {
      handlers.forEach(handler => handler(data));
    }
  }
}

// Usage
const editor = new TypedEventEmitter();

editor.on(EditorEvents.OPERATION, (data) => {
  console.log('Operation:', data.operation);
});

editor.on(EditorEvents.ERROR, (data) => {
  console.error('Error:', data.error);
});

editor.emit(EditorEvents.OPERATION, { 
  operation: { type: 'insertText', text: 'Hello' } 
});`} />
              </DocSection>

              <DocSection id="event-priority" title="이벤트 우선순위" depth={3}>
                <p class="m-0 mb-3">
                  순서가 있는 이벤트 처리를 위한 이벤트 우선순위를 지원합니다:
                </p>
                <DocCodeBlock language="typescript" code={`class PriorityEventEmitter {
  #listeners = new Map();
  
  on(event, handler, priority = 0) {
    if (!this.#listeners.has(event)) {
      this.#listeners.set(event, []);
    }
    
    const listeners = this.#listeners.get(event);
    listeners.push({ handler, priority });
    
    // Sort by priority (higher priority first)
    listeners.sort((a, b) => b.priority - a.priority);
  }
  
  emit(event, data) {
    const listeners = this.#listeners.get(event);
    if (listeners) {
      listeners.forEach(({ handler }) => {
        handler(data);
      });
    }
  }
}

// Usage
const emitter = new PriorityEventEmitter();

// High priority handler (runs first)
emitter.on('operation', (data) => {
  console.log('High priority:', data);
}, 100);

// Normal priority handler
emitter.on('operation', (data) => {
  console.log('Normal priority:', data);
}, 0);

// Low priority handler (runs last)
emitter.on('operation', (data) => {
  console.log('Low priority:', data);
}, -100);`} />
              </DocSection>
            </DocSection>

            <DocSection id="event-lifecycle" title="이벤트 생명주기">
              <p class="m-0 mb-4">
                완전한 이벤트 생명주기 관리:
              </p>
              <DocCodeBlock language="typescript" code={`class EventLifecycle {
  #preHandlers = new Map();
  #handlers = new Map();
  #postHandlers = new Map();
  
  on(event, handler, phase = 'main') {
    const map = phase === 'pre' 
      ? this.#preHandlers 
      : phase === 'post' 
        ? this.#postHandlers 
        : this.#handlers;
    
    if (!map.has(event)) {
      map.set(event, new Set());
    }
    map.get(event).add(handler);
  }
  
  emit(event, data) {
    // Pre-handlers
    this.#callHandlers(this.#preHandlers, event, data);
    
    // Main handlers
    const result = this.#callHandlers(this.#handlers, event, data);
    
    // Post-handlers
    this.#callHandlers(this.#postHandlers, event, data);
    
    return result;
  }
  
  #callHandlers(map, event, data) {
    const handlers = map.get(event);
    if (handlers) {
      handlers.forEach(handler => handler(data));
    }
  }
  
  // Prevent default behavior
  preventDefault(event) {
    event.defaultPrevented = true;
  }
  
  // Stop propagation
  stopPropagation(event) {
    event.propagationStopped = true;
  }
}`} />
            </DocSection>

            <DocNavigation
              current={localePath('/editor/architecture/event-system')}
              pages={[
                { title: '에디터 아키텍처', href: localePath('/editor/architecture'), description: '에디터 아키텍처 패턴 개요' },
                { title: '비동기 초기화', href: localePath('/editor/architecture/async-initialization'), description: 'Promise 기반 초기화 및 생명주기' },
                { title: '훅 시스템', href: localePath('/editor/architecture/hook-system'), description: '훅 시스템 구현 이해' },
                { title: '성능 최적화', href: localePath('/editor/architecture/performance-optimization'), description: '대용량 문서를 위한 최적화 전략' },
                { title: '렌더링 파이프라인', href: localePath('/editor/architecture/rendering-pipeline'), description: '렌더링 파이프라인 및 업데이트 스케줄링' },
              ]}
            />
          </article>
        </div>
        <TableOfContents headings={headings} />
      </section>
    </main>
  </body>
</html>
