---
import DocLayout from '../../components/docs/DocLayout.astro';
import DocSection from '../../components/docs/DocSection.astro';
import DocCodeBlock from '../../components/docs/DocCodeBlock.astro';
import DocAlert from '../../components/docs/DocAlert.astro';
import DocInfoBox from '../../components/docs/DocInfoBox.astro';
import EditorExample from '../../components/EditorExample.astro';
import TableOfContents from '../../components/TableOfContents.astro';
import '../../styles/global.css';

// Define headings for TOC
const headings = [
  { depth: 2, slug: 'getting-the-selection', text: 'Getting the selection' },
  { depth: 2, slug: 'range-api', text: 'Range API' },
  { depth: 2, slug: 'node-selection', text: 'Node Selection' },
  { depth: 2, slug: 'native-selection-visualization', text: 'Native Selection Visualization' },
  { depth: 2, slug: 'selection-synchronization-with-internal-models', text: 'Selection Synchronization with Internal Models' },
  { depth: 2, slug: 'common-issues', text: 'Common issues' },
];

const getSelectionCode = `const selection = window.getSelection();

if (selection && selection.rangeCount > 0) {
  const range = selection.getRangeAt(0);
  console.log('Selected text:', range.toString());
  console.log('Start:', range.startOffset);
  console.log('End:', range.endOffset);
}`;

const rangeCode = `// Create a new range
const range = document.createRange();

// Set the range to cover specific content
range.setStart(element.firstChild, 5);
range.setEnd(element.firstChild, 10);

// Apply the range to the selection
const selection = window.getSelection();
selection.removeAllRanges();
selection.addRange(range);`;

const nodeSelectionCode = `// Select an entire node (e.g., an image or div)
const range = document.createRange();
range.selectNode(element); // Selects the entire element node

// Or select the contents of a node
range.selectNodeContents(element); // Selects all children, but not the element itself

// Apply to selection
const selection = window.getSelection();
selection.removeAllRanges();
selection.addRange(range);`;
---

<DocLayout
  title="Selection API"
  description="Working with text selection, ranges, and the Selection API in contenteditable elements."
  currentPath={Astro.url.pathname}
>
        <DocSection id="getting-the-selection" title="Getting the selection">
          <p class="m-0 mb-4">
            The <code class="bg-bg-muted px-1.5 py-0.5 rounded text-[0.85em]">window.getSelection()</code> method returns a Selection object representing the current text selection.
          </p>
          <DocCodeBlock code={getSelectionCode} />
        </DocSection>

        <DocSection id="range-api" title="Range API">
          <p class="m-0 mb-4">
            A Range represents a contiguous portion of the document. You can create, modify, and manipulate ranges programmatically.
          </p>
          <DocCodeBlock code={rangeCode} />
        </DocSection>

        <DocSection id="node-selection" title="Node Selection">
          <p class="m-0 mb-4">
            Unlike text selection, which selects characters within text nodes, <strong>node selection</strong> selects entire element nodes (like images, divs, or other HTML elements). This is useful when you want to select non-text content or entire blocks of content.
          </p>

          <div style="margin: 1.5rem 0; padding: 1.5rem; background: var(--bg-muted); border-radius: 0.5rem; border: 1px solid var(--border-light);">
            <h3 style="font-size: 1rem; margin: 0 0 1rem 0; color: var(--text-primary);">
              Text Selection vs Node Selection
            </h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 1rem;">
              <!-- Text Selection -->
              <div style="background: var(--bg-surface); padding: 1rem; border-radius: 0.375rem; border: 1px solid var(--border-light);">
                <h4 style="font-size: 0.9rem; margin: 0 0 0.75rem 0; color: var(--text-primary); font-weight: 600;">
                  Text Selection
                </h4>
                <div style="font-size: 0.85rem; line-height: 1.6; color: var(--text-secondary); margin-bottom: 0.75rem;">
                  <p style="margin: 0; padding: 0.5rem; background: var(--bg-page); border-radius: 0.25rem; border: 1px solid var(--border-light);">
                    This is a <span style="background: rgba(66, 133, 244, 0.3); padding: 0 2px; border-radius: 2px;">paragraph</span> with text.
                  </p>
                </div>
                <div style="font-size: 0.75rem; color: var(--text-muted);">
                  <div><strong>Container:</strong> #text node</div>
                  <div><strong>Offset:</strong> Character position (0, 1, 2...)</div>
                  <div><strong>Example:</strong> startOffset: 10, endOffset: 19</div>
                </div>
              </div>

              <!-- Node Selection -->
              <div style="background: var(--bg-surface); padding: 1rem; border-radius: 0.375rem; border: 1px solid var(--border-light);">
                <h4 style="font-size: 0.9rem; margin: 0 0 0.75rem 0; color: var(--text-primary); font-weight: 600;">
                  Node Selection
                </h4>
                <div style="font-size: 0.85rem; line-height: 1.6; color: var(--text-secondary); margin-bottom: 0.75rem;">
                  <div style="padding: 0.5rem; background: var(--bg-page); border-radius: 0.25rem; border: 2px solid rgba(66, 133, 244, 0.5);">
                    <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='60'%3E%3Crect fill='%23e5e7eb' width='100' height='60'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='Arial' font-size='12' fill='%236b7280'%3EImage%3C/text%3E%3C/svg%3E" alt="Selected image" style="display: block; max-width: 100%; height: auto;" />
                  </div>
                </div>
                <div style="font-size: 0.75rem; color: var(--text-muted);">
                  <div><strong>Container:</strong> Element node (IMG, DIV, etc.)</div>
                  <div><strong>Offset:</strong> Child index (0, 1, 2...)</div>
                  <div><strong>Example:</strong> startOffset: 0, endOffset: 1</div>
                </div>
              </div>
            </div>

            <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-surface); border-radius: 0.375rem; border: 1px solid var(--border-light);">
              <h4 style="font-size: 0.9rem; margin: 0 0 0.75rem 0; color: var(--text-primary); font-weight: 600;">
                Visual Comparison
              </h4>
              <div style="font-size: 0.85rem; line-height: 1.8; color: var(--text-secondary);">
                <div style="margin-bottom: 0.5rem;">
                  <strong style="color: var(--text-primary);">Text Selection:</strong> Highlights characters within a text node. The selection appears as a colored background over the selected text.
                </div>
                <div>
                  <strong style="color: var(--text-primary);">Node Selection:</strong> Selects the entire element. Visual representation varies by browser - some show borders, some show background, some may not show any visual indication.
                </div>
              </div>
            </div>
          </div>

          <DocAlert type="error" title="⚠️ Important">
            <p class="m-0 text-sm">
              You cannot create a selection using just a node object. A node by itself is not selectable - you must use the <code class="bg-white/50 dark:bg-black/20 px-1.5 py-0.5 rounded text-[0.85em]">Range</code> API to define selection boundaries, then apply it to the <code class="bg-white/50 dark:bg-black/20 px-1.5 py-0.5 rounded text-[0.85em]">Selection</code> object. The Range acts as a bridge between the node and the selection.
            </p>
          </DocAlert>

          <h3 class="text-lg my-6 mb-3 text-text-primary">
            Selecting Entire Nodes
          </h3>
          <p class="m-0 mb-4">
            Use <code class="bg-bg-muted px-1.5 py-0.5 rounded text-[0.85em]">range.selectNode(node)</code> to select an entire element node, including the element itself. This requires creating a Range first:
          </p>
          <DocCodeBlock code={nodeSelectionCode} />

          <h3 class="text-lg my-6 mb-3 text-text-primary">
            Key Differences from Text Selection
          </h3>
          <ul class="m-0 mb-4 pl-6">
            <li class="mb-2">
              <strong>Container type:</strong> In node selection, <code class="bg-bg-muted px-1.5 py-0.5 rounded text-[0.85em]">startContainer</code> and <code class="bg-bg-muted px-1.5 py-0.5 rounded text-[0.85em]">endContainer</code> are element nodes, not text nodes.
            </li>
            <li class="mb-2">
              <strong>Offset meaning:</strong> When the container is an element node, <code class="bg-bg-muted px-1.5 py-0.5 rounded text-[0.85em]">startOffset</code> and <code class="bg-bg-muted px-1.5 py-0.5 rounded text-[0.85em]">endOffset</code> represent child node indices (0, 1, 2...), not character positions.
            </li>
            <li class="mb-2">
              <strong>Visual appearance:</strong> Node selections may appear differently across browsers. Some browsers show a border or outline around selected elements, while others may not visually distinguish node selections from text selections.
            </li>
            <li class="mb-2">
              <strong>Common use cases:</strong> Selecting images, selecting entire paragraphs or blocks, programmatically selecting content for clipboard operations.
            </li>
          </ul>

          <div class="mt-6 p-4 bg-bg-surface rounded-lg border border-border-light">
            <h4 class="text-[0.95rem] m-0 mb-3 text-text-primary">
              Why Range is Required
            </h4>
            <p class="m-0 mb-3 text-[0.9rem] text-text-secondary">
              A node object alone cannot be directly selected. The Selection API requires a Range object that defines the boundaries of what to select. Here's the process:
            </p>
            <ol class="m-0 mb-3 pl-6 text-[0.9rem] text-text-secondary">
              <li class="mb-2">
                <strong>Get the node:</strong> <code class="bg-bg-muted px-1.5 py-0.5 rounded text-[0.85em]">const node = document.getElementById('myImage');</code>
              </li>
              <li class="mb-2">
                <strong>Create a Range:</strong> <code class="bg-bg-muted px-1.5 py-0.5 rounded text-[0.85em]">const range = document.createRange();</code>
              </li>
              <li class="mb-2">
                <strong>Select the node with Range:</strong> <code class="bg-bg-muted px-1.5 py-0.5 rounded text-[0.85em]">range.selectNode(node);</code>
              </li>
              <li class="mb-2">
                <strong>Apply Range to Selection:</strong> <code class="bg-bg-muted px-1.5 py-0.5 rounded text-[0.85em]">selection.addRange(range);</code>
              </li>
            </ol>
            <p class="mt-3 m-0 text-[0.85rem] text-text-muted">
              Without the Range step, you cannot select a node. The Range object is the mechanism that tells the browser "select this node" or "select from this position to that position."
            </p>
          </div>

          <div class="mt-6 p-4 bg-bg-muted rounded-lg border border-border-light">
            <h4 class="text-[0.95rem] m-0 mb-3 text-text-primary">
              Example: Detecting Node Selection
            </h4>
            <pre class="bg-bg-surface border border-border-light rounded-md p-3 overflow-x-auto text-sm leading-relaxed text-text-primary m-0"><code>{`const selection = window.getSelection();
if (selection && selection.rangeCount > 0) {
  const range = selection.getRangeAt(0);
  
  // Check if selection is a node selection
  const isNodeSelection = 
    range.startContainer.nodeType === Node.ELEMENT_NODE ||
    range.endContainer.nodeType === Node.ELEMENT_NODE;
  
  if (isNodeSelection) {
    console.log('Node selection detected');
    console.log('Selected node:', range.startContainer);
    console.log('Child index:', range.startOffset);
  }
}`}</code></pre>
          </div>

          <div class="mt-6 p-4 bg-bg-muted rounded-lg border border-border-light">
            <h4 class="text-[0.95rem] m-0 mb-3 text-text-primary">
              Important Notes
            </h4>
            <ul class="m-0 pl-6 text-[0.9rem]">
              <li class="mb-2">
                Node selection is less common in user interactions compared to text selection. Most users select text, not entire elements.
              </li>
              <li class="mb-2">
                When <code class="bg-bg-surface px-1.5 py-0.5 rounded text-[0.85em]">startContainer</code> is an element node, <code class="bg-bg-surface px-1.5 py-0.5 rounded text-[0.85em]">startOffset</code> refers to the index of the child node, not a character position.
              </li>
              <li class="mb-2">
                <code class="bg-bg-surface px-1.5 py-0.5 rounded text-[0.85em]">range.toString()</code> on a node selection returns the text content of all descendant text nodes, which may not represent the actual selected element.
              </li>
              <li class="mb-2">
                Some browsers handle node selection differently in contenteditable regions, especially for inline elements like images or links.
              </li>
            </ul>
          </div>
        </section>

        <DocSection id="native-selection-visualization" title="Native Selection Visualization">
          <p class="m-0 mb-4">
            Browsers render text selections using their native styling. The visual appearance of selections varies by browser and operating system. Try selecting text in the contenteditable area below to see how your browser displays selections:
          </p>
          
          <div class="bg-bg-surface border-2 border-border-medium rounded-lg p-6 my-4">
            <div
              contenteditable="true"
              id="selection-demo"
              class="min-h-[120px] p-4 bg-bg-page border border-border-light rounded-md outline-none text-base leading-relaxed"
            >
              <p>This is a <strong>contenteditable</strong> paragraph with <em>various</em> inline elements.</p>
              <p>Select some text above to see how your browser renders the native selection. The selection appearance depends on your browser and operating system.</p>
              <p>You can also select across multiple paragraphs and elements to observe how the selection behaves at element boundaries.</p>
            </div>
            
            <div
              id="selection-info"
              class="mt-4 p-3 bg-bg-muted border border-border-light rounded-md text-sm font-mono text-text-secondary"
            >
              <div class="mb-2"><strong>Selection Info:</strong></div>
              <div id="selection-details" class="text-text-primary">No selection</div>
            </div>
          </div>

          <div style="margin-top: 1.5rem; padding: 1rem; background: var(--bg-muted); border-radius: 0.5rem; border: 1px solid var(--border-light);">
            <h3 style="font-size: 1rem; margin: 0 0 0.75rem 0; color: var(--text-primary);">
              Browser Selection Styles
            </h3>
            <p style="margin: 0 0 0.75rem 0; font-size: 0.9rem;">
              Different browsers and operating systems use different default selection colors:
            </p>
            <ul style="margin: 0; padding-left: 1.5rem; font-size: 0.9rem;">
              <li style="margin-bottom: 0.5rem;">
                <strong>Chrome/Edge (Windows):</strong> Blue background (#4285f4)
              </li>
              <li style="margin-bottom: 0.5rem;">
                <strong>Firefox (Windows):</strong> Blue background (#0060df)
              </li>
              <li style="margin-bottom: 0.5rem;">
                <strong>Safari (macOS):</strong> Light blue background (#007aff)
              </li>
              <li style="margin-bottom: 0.5rem;">
                <strong>Chrome (macOS):</strong> Light blue background (#007aff)
              </li>
              <li style="margin-bottom: 0.5rem;">
                <strong>Mobile browsers:</strong> Varies by platform, often uses system accent color
              </li>
            </ul>
            <p style="margin: 0.75rem 0 0 0; font-size: 0.85rem; color: var(--text-muted);">
              Note: The selection color can be customized using CSS <code style="background: var(--bg-surface); padding: 0.15rem 0.4rem; border-radius: 4px; font-size: 0.85em;">::selection</code> pseudo-element, but the default browser behavior is what users see by default.
            </p>
          </div>
        </section>

        <DocSection id="selection-synchronization-with-internal-models" title="Selection Synchronization with Internal Models">
          <p class="m-0 mb-4">
            One of the most challenging aspects of building contenteditable editors is maintaining synchronization between the browser's DOM-based Selection API and your editor's internal data model (like Slate, ProseMirror, or custom models).
          </p>

          <div class="my-6 p-6 bg-bg-muted rounded-lg border border-border-light">
            <h3 class="text-lg m-0 mb-4 text-text-primary">
              The Core Problem
            </h3>
            <div class="grid grid-cols-2 gap-6 mb-4">
              <div class="bg-bg-surface p-4 rounded-md border border-border-light">
                <h4 class="text-[0.95rem] m-0 mb-3 text-text-primary font-semibold">
                  Browser Selection (DOM-based)
                </h4>
                <ul class="m-0 pl-6 text-[0.9rem] text-text-secondary">
                  <li class="mb-2">Uses DOM nodes and offsets</li>
                  <li class="mb-2">Changes with every user interaction</li>
                  <li class="mb-2">No concept of "blocks" or "nodes"</li>
                  <li class="mb-2">Tied to actual DOM structure</li>
                </ul>
              </div>
              <div class="bg-bg-surface p-4 rounded-md border border-border-light">
                <h4 class="text-[0.95rem] m-0 mb-3 text-text-primary font-semibold">
                  Editor Model (Abstract)
                </h4>
                <ul class="m-0 pl-6 text-[0.9rem] text-text-secondary">
                  <li class="mb-2">Uses abstract paths/positions</li>
                  <li class="mb-2">Represents document structure</li>
                  <li class="mb-2">Has "block" and "inline" concepts</li>
                  <li class="mb-2">Independent of DOM</li>
                </ul>
              </div>
            </div>
            <p class="m-0 text-[0.9rem] text-text-secondary">
              These two representations must be kept in sync at all times, which requires constant bidirectional conversion.
            </p>
          </div>

          <h3 class="text-lg my-6 mb-3 text-text-primary">
            Continuous Synchronization Required
          </h3>
          <p class="m-0 mb-4">
            Because the browser's Selection API is DOM-based and your editor model is abstract, you need to continuously synchronize between them:
          </p>
          <ul class="m-0 mb-4 pl-6">
            <li class="mb-3">
              <strong>DOM → Model:</strong> When the user selects text, you must convert the DOM Range to your model's path/offset representation.
            </li>
            <li class="mb-3">
              <strong>Model → DOM:</strong> When your model changes (e.g., undo/redo, programmatic edits), you must update the DOM and restore the selection.
            </li>
            <li class="mb-3">
              <strong>After every DOM mutation:</strong> The selection may become invalid, requiring normalization and restoration.
            </li>
          </ul>

          <div class="my-6 p-4 bg-blue-100 dark:bg-blue-900/20 border border-blue-500 dark:border-blue-700 rounded-lg">
            <h4 class="text-[0.95rem] m-0 mb-3 text-blue-800 dark:text-blue-200 font-semibold">
              Example: Selection Normalization Flow
            </h4>
            <pre class="bg-bg-surface border border-border-light rounded-md p-3 overflow-x-auto text-sm leading-relaxed text-text-primary m-0 mb-3"><code>{`// 1. User selects text → DOM Range
const domRange = selection.getRangeAt(0);

// 2. Convert DOM Range to model path
const modelPath = domRangeToModelPath(domRange);
// Result: [{ block: 0, offset: 5 }, { block: 0, offset: 10 }]

// 3. Normalize: ensure path is valid in current model
const normalizedPath = normalizePath(modelPath, editorModel);

// 4. Store in model
editorModel.selection = normalizedPath;

// 5. When model changes, convert back to DOM
const newDomRange = modelPathToDomRange(normalizedPath, editorModel);
selection.removeAllRanges();
selection.addRange(newDomRange);`}</code></pre>
          </div>

          <h3 class="text-lg my-6 mb-3 text-text-primary">
            Handling Node Selection in Different Editors
          </h3>
          <p class="m-0 mb-4">
            Even though the browser's Range API represents node selections using element nodes and child indices, different editor frameworks handle this differently in their internal models. Here's how major editors approach node selection:
          </p>

          <EditorExample
            editor="slate"
            title="Node Selection Handling"
            description="Slate uses path-based selection. Node selection is represented by selecting the entire node at a specific path:"
            code={`// Detect node selection from DOM Range
const range = selection.getRangeAt(0);
if (range.startContainer.nodeType === Node.ELEMENT_NODE) {
  // Find the Slate node path
  const slatePath = ReactEditor.findPath(editor, range.startContainer);
  
  // Set selection to the entire node
  Transforms.select(editor, {
    anchor: { path: slatePath, offset: 0 },
    focus: { path: slatePath, offset: 1 }, // Select entire node
  });
  
  // Or use Editor.nodes() to work with selected nodes
  for (const [node, path] of Editor.nodes(editor, {
    at: slatePath,
    mode: 'lowest',
  })) {
    // Handle selected node
  }
}`}
            features={[
              '<strong>Path-based:</strong> Node selection uses the same path format as text selection, but with offset 0-1 to indicate the entire node.',
              '<strong>Unified API:</strong> Same <code class="bg-bg-surface px-1.5 py-0.5 rounded text-[0.85em]">Transforms.select()</code> API for both text and node selections.',
              '<strong>Detection:</strong> Use <code class="bg-bg-surface px-1.5 py-0.5 rounded text-[0.85em]">Editor.nodes()</code> or check if <code class="bg-bg-surface px-1.5 py-0.5 rounded text-[0.85em]">Range.isCollapsed</code> and path offsets.',
            ]}
          />

          <EditorExample
            editor="prosemirror"
            title="Node Selection Handling"
            description="ProseMirror has a dedicated NodeSelection class that explicitly represents node selections:"
            code={`// Detect node selection from DOM Range
const range = selection.getRangeAt(0);
if (range.startContainer.nodeType === Node.ELEMENT_NODE) {
  // Find the ProseMirror node and position
  const pos = editorView.posAtDOM(range.startContainer, 0);
  const $pos = editorView.state.doc.resolve(pos);
  const node = $pos.nodeAfter || $pos.nodeBefore;
  
  if (node && node.isAtom) { // Images, embeds, etc.
    // Create NodeSelection
    const nodeSelection = NodeSelection.create(
      editorView.state.doc,
      $pos.pos
    );
    
    // Apply selection
    const tr = editorView.state.tr.setSelection(nodeSelection);
    editorView.dispatch(tr);
  }
}`}
            features={[
              '<strong>Separate class:</strong> <code class="bg-bg-surface px-1.5 py-0.5 rounded text-[0.85em]">NodeSelection</code> is distinct from <code class="bg-bg-surface px-1.5 py-0.5 rounded text-[0.85em]">TextSelection</code>.',
              '<strong>Atom nodes:</strong> Only "atom" nodes (images, embeds, etc.) can be node-selected, not regular block nodes.',
              '<strong>Position-based:</strong> Uses document positions, not paths like Slate.',
            ]}
          />

          <EditorExample
            editor="draftjs"
            title="Node Selection Handling"
            description="Draft.js has limited support for node selection. It primarily focuses on text selection within blocks:"
            code={`// Draft.js doesn't have native node selection
// You need to handle it manually by:
// 1. Detecting node selection from DOM Range
// 2. Converting to block key and offset
// 3. Using EditorState.forceSelection() with a collapsed selection

const range = selection.getRangeAt(0);
if (range.startContainer.nodeType === Node.ELEMENT_NODE) {
  // Find the block key
  const blockKey = getBlockKeyForNode(range.startContainer);
  
  // Create a collapsed selection at the block
  const selectionState = SelectionState.createEmpty(blockKey);
  const newEditorState = EditorState.forceSelection(
    editorState,
    selectionState
  );
}`}
            features={[
              '<strong>Limited support:</strong> Draft.js doesn\'t have built-in node selection support.',
              '<strong>Workaround:</strong> Convert node selection to a collapsed text selection at the block level.',
              '<strong>Block-based:</strong> Works with block keys, not individual nodes.',
            ]}
          />

          <div class="my-6 p-4 bg-blue-100 dark:bg-blue-900/20 border border-blue-500 dark:border-blue-700 rounded-lg">
            <h4 class="text-[0.95rem] m-0 mb-3 text-blue-800 dark:text-blue-200 font-semibold">
              Key Takeaway
            </h4>
            <p class="m-0 text-[0.9rem] text-blue-800 dark:text-blue-200">
              Even though the browser's Range API represents node selections uniformly (using element nodes and child indices), each editor framework converts this to its own internal representation. The conversion strategy depends on:
            </p>
            <ul class="m-0 mt-3 pl-6 text-[0.9rem] text-blue-800 dark:text-blue-200">
              <li class="mb-2">The editor's data model structure (path-based, position-based, block-based)</li>
              <li class="mb-2">Whether the editor distinguishes between text and node selections</li>
              <li class="mb-2">Which nodes are selectable (all nodes vs. only atom/void nodes)</li>
              <li class="mb-2">How the editor handles selection restoration after DOM mutations</li>
            </ul>
          </div>

          <h3 class="text-lg my-6 mb-3 text-text-primary">
            No Block Selection Concept in Browser API
          </h3>
          <p class="m-0 mb-4">
            The browser's Selection API has no concept of "block selection" or "node selection" in the way that editor models do. The browser only knows about:
          </p>
          <ul class="m-0 mb-4 pl-6">
            <li class="mb-2">
              <strong>Text nodes and character offsets:</strong> For text selections
            </li>
            <li class="mb-2">
              <strong>Element nodes and child indices:</strong> For node selections
            </li>
          </ul>
          <p class="m-0 mb-4">
            This means you must always normalize selections relative to the parent element, converting between:
          </p>
          <div class="my-4 p-4 bg-bg-surface rounded-lg border border-border-light">
            <div class="text-[0.9rem] leading-[1.8] text-text-secondary">
              <div class="mb-3">
                <strong class="text-text-primary">DOM representation:</strong><br/>
                <code class="bg-bg-muted px-1.5 py-0.5 rounded text-[0.85em]">startContainer: P#paragraph-1 > #text @ 5</code><br/>
                <code class="bg-bg-muted px-1.5 py-0.5 rounded text-[0.85em]">endContainer: P#paragraph-1 > #text @ 10</code>
              </div>
              <div>
                <strong class="text-text-primary">Model representation (normalized):</strong><br/>
                <code class="bg-bg-muted px-1.5 py-0.5 rounded text-[0.85em]">path: [0, 5] to [0, 10]</code><br/>
                <span class="text-[0.85rem] text-text-muted">(block index 0, character offset 5-10)</span>
              </div>
            </div>
          </div>

          <div class="my-6 p-4 bg-yellow-100 dark:bg-yellow-900/20 border border-yellow-500 dark:border-yellow-700 rounded-lg">
            <h4 class="text-[0.95rem] m-0 mb-3 text-yellow-800 dark:text-yellow-200 font-semibold">
              ⚠️ Normalization Challenges
            </h4>
            <ul class="m-0 pl-6 text-[0.9rem] text-yellow-800 dark:text-yellow-200">
              <li class="mb-2">
                <strong>Parent-based normalization:</strong> Since there's no block concept, you must always calculate positions relative to the parent element, which can change when the DOM structure is modified.
              </li>
              <li class="mb-2">
                <strong>Cross-boundary selections:</strong> When a selection spans multiple blocks, you need to handle the conversion for each block segment separately.
              </li>
              <li class="mb-2">
                <strong>Invalid ranges after mutations:</strong> After any DOM mutation (insert, delete, split, merge), the stored Range may point to removed nodes, requiring immediate normalization.
              </li>
              <li class="mb-2">
                <strong>Performance:</strong> Constant synchronization can be expensive, especially with large documents or frequent updates.
              </li>
            </ul>
          </div>

          <div class="my-6 p-4 bg-bg-muted rounded-lg border border-border-light">
            <h4 class="text-[0.95rem] m-0 mb-3 text-text-primary">
              Best Practices
            </h4>
            <ul class="m-0 pl-6 text-[0.9rem] text-text-secondary">
              <li class="mb-2">
                <strong>Store normalized paths in your model:</strong> Always convert DOM selections to model paths immediately and store them.
              </li>
              <li class="mb-2">
                <strong>Normalize after every mutation:</strong> After any DOM change, check if the selection is still valid and normalize if needed.
              </li>
              <li class="mb-2">
                <strong>Use path-based selection:</strong> Instead of storing DOM references, store abstract paths (e.g., <code class="bg-bg-surface px-1.5 py-0.5 rounded text-[0.85em]">[blockIndex, offset]</code>) that can be resolved to DOM positions when needed.
              </li>
              <li class="mb-2">
                <strong>Debounce normalization:</strong> For performance, batch multiple selection changes and normalize once per frame.
              </li>
              <li class="mb-2">
                <strong>Handle edge cases:</strong> Empty selections, collapsed selections, selections at block boundaries, and cross-block selections all need special handling.
              </li>
            </ul>
          </div>
        </section>

        <DocSection id="common-issues" title="Common issues">
          <div class="mb-6">
            <h3 class="text-lg m-0 mb-2 text-text-primary">
              Selection lost on focus change
            </h3>
            <p class="m-0 mb-2">
              When a contenteditable loses focus, <code class="bg-bg-muted px-1.5 py-0.5 rounded text-[0.85em]">window.getSelection()</code> may return <code class="bg-bg-muted px-1.5 py-0.5 rounded text-[0.85em]">null</code> or an empty selection, making it difficult to preserve selection state.
            </p>
            <p class="m-0 text-[0.85rem] text-text-muted">
              See cases: <a href="/scenarios/scenario-selection-api-behavior" class="text-accent-primary">scenario-selection-api-behavior</a>
            </p>
          </div>

          <div class="mb-6">
            <h3 class="text-lg m-0 mb-2 text-text-primary">
              Incorrect range boundaries
            </h3>
            <p class="m-0 mb-2">
              When selecting text that spans multiple elements, the Range boundaries may not accurately reflect the visual selection, especially across element boundaries.
            </p>
            <p class="m-0 text-[0.85rem] text-text-muted">
              See cases: <a href="/scenarios/scenario-selection-range-accuracy" class="text-accent-primary">scenario-selection-range-accuracy</a>
            </p>
          </div>

          <div>
            <h3 class="text-lg m-0 mb-2 text-text-primary">
              Selection collapse on blur
            </h3>
            <p class="m-0 mb-2">
              Clicking outside a contenteditable may collapse the selection unexpectedly, even when the click target is within the same document.
            </p>
            <p class="m-0 text-[0.85rem] text-text-muted">
              See cases: <a href="/scenarios/scenario-selection-collapse-on-blur" class="text-accent-primary">scenario-selection-collapse-on-blur</a>
            </p>
          </div>
        </section>

        <section>
          <h2
            style="
              font-size: 1.3rem;
              margin: 0 0 0.75rem 0;
              padding-bottom: 0.5rem;
              border-bottom: 2px solid var(--border-light);
            "
          >
            Related resources
          </h2>
          <ul style="margin: 0; padding-left: 1.5rem;">
            <li style="margin-bottom: 0.5rem;">
              <a
                href="/cases?tag=selection"
                style="color: var(--accent-primary); text-decoration: none;"
              >
                Browse selection-related cases →
              </a>
            </li>
            <li style="margin-bottom: 0.5rem;">
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/API/Selection"
                target="_blank"
                rel="noopener noreferrer"
                style="color: var(--accent-primary); text-decoration: none;"
              >
                MDN: Selection API (external) →
              </a>
            </li>
          </ul>
        </section>
  <TableOfContents slot="toc" headings={headings} />
</DocLayout>

    <script>
      // Selection visualization script
      const demoEl = document.getElementById('selection-demo');
      const infoEl = document.getElementById('selection-info');
      const detailsEl = document.getElementById('selection-details');

      function updateSelectionInfo() {
        const selection = window.getSelection();
        
        if (!selection || selection.rangeCount === 0 || selection.isCollapsed) {
          detailsEl.textContent = 'No selection';
          return;
        }

        const range = selection.getRangeAt(0);
        const selectedText = range.toString();
        
        const info = {
          text: selectedText.length > 50 ? selectedText.substring(0, 50) + '...' : selectedText,
          length: selectedText.length,
          startContainer: range.startContainer.nodeName === '#text' 
            ? `#text (parent: ${range.startContainer.parentElement?.tagName || 'none'})`
            : range.startContainer.nodeName,
          endContainer: range.endContainer.nodeName === '#text'
            ? `#text (parent: ${range.endContainer.parentElement?.tagName || 'none'})`
            : range.endContainer.nodeName,
          startOffset: range.startOffset,
          endOffset: range.endOffset,
          collapsed: range.collapsed,
          commonAncestor: range.commonAncestorContainer.nodeName === '#text'
            ? `#text (parent: ${range.commonAncestorContainer.parentElement?.tagName || 'none'})`
            : range.commonAncestorContainer.nodeName,
        };

        detailsEl.innerHTML = `
          <div style="margin-bottom: 0.25rem;"><strong>Text:</strong> "${info.text}" (${info.length} chars)</div>
          <div style="margin-bottom: 0.25rem;"><strong>Start:</strong> ${info.startContainer} @ ${info.startOffset}</div>
          <div style="margin-bottom: 0.25rem;"><strong>End:</strong> ${info.endContainer} @ ${info.endOffset}</div>
          <div style="margin-bottom: 0.25rem;"><strong>Common Ancestor:</strong> ${info.commonAncestor}</div>
          <div><strong>Collapsed:</strong> ${info.collapsed ? 'Yes' : 'No'}</div>
        `;
      }

      // Update on selection change
      document.addEventListener('selectionchange', updateSelectionInfo);
      
      // Also update on mouse/keyboard events in the demo area
      if (demoEl) {
        demoEl.addEventListener('mouseup', updateSelectionInfo);
        demoEl.addEventListener('keyup', updateSelectionInfo);
        demoEl.addEventListener('focus', () => {
          setTimeout(updateSelectionInfo, 0);
        });
      }
    </script>
  </body>
</html>

